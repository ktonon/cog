<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  File: README
  
    &mdash; Documentation by YARD 0.8.3
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'><p><img src="http://ktonon.github.com/cog/images/cog-logo-small.png" alt="cog"></p>

<p><a href="https://travis-ci.org/ktonon/cog"><img src="https://secure.travis-ci.org/ktonon/cog.png?branch=master" alt="Build Status"></a>
<a href="https://gemnasium.com/ktonon/cog"><img src="https://gemnasium.com/ktonon/cog.png" alt="Dependency Status"></a>
<a href="https://codeclimate.com/github/ktonon/cog"><img src="https://codeclimate.com/badge.png" alt="Code Climate"></a></p>

<p><code>cog</code> is a command line utility that makes it easy to organize a project which
uses code generation.</p>

<p>Note that <em>this project is still under development</em>.</p>

<h2>Getting Started</h2>

<p>Install the <code>cog</code> gem</p>

<pre class="code bash"><code>$ gem install cog
</code></pre>

<p>Once installed prepare a project for use with <code>cog</code>. Open a terminal in the root directory of your project</p>

<pre class="code bash"><code>$ cog init
Created Cogfile
</code></pre>

<p>This will add a <a href="http://ktonon.github.com/cog/Cog/DSL/Cogfile.html">Cogfile</a> which configures <code>cog</code> for use with the project. In
short, it tells <code>cog</code> where to find generators and templates and where to put
generated source code. Open the <code>Cogfile</code> to find out more, each setting is
documented. Most settings can be left as-is, but the <code>project_path</code> might
need to be changed.</p>

<h2>Generators</h2>

<p>A generator is a ruby script which resides on the <a href="http://ktonon.github.com/cog/Cog/Config.html#generator_path-instance_method">generator_path</a>. A basic
generator can be created using the command line tool once a project has been
initialized</p>

<pre class="code bash"><code>$ cog generator new my_generator
Created cog/generators/my_generator.rb
</code></pre>

<p><code>my_generator.rb</code> will contain a blank canvas. Generator scripts are evaluated
as instances of <a href="http://ktonon.github.com/cog/Cog/GeneratorSandbox.html">GeneratorSandbox</a>. The sandbox includes the <a href="http://ktonon.github.com/cog/Cog/Generator.html">Generator</a>
mixin, which provides an interface for easily generating source code from
templates. The <a href="http://ktonon.github.com/cog/Cog/Generator.html#method-i-stamp">stamp</a> method is particularly useful. If finds an <a href="http://www.stuartellis.eu/articles/erb/">ERB</a>
template on the <a href="http://ktonon.github.com/cog/Cog/Config.html#template_path-instance_method">template_path</a> and renders it to a file under the
<a href="http://ktonon.github.com/cog/Cog/Config/ProjectConfig.html#project_path-instance_method">project_path</a>. To use the <a href="http://ktonon.github.com/cog/Cog/Generator.html#method-i-stamp">stamp</a> method first create a template</p>

<pre class="code ruby"><code>$ <span class='rubyid_cog identifier id'>cog</span> <span class='rubyid_template identifier id'>template</span> <span class='rubyid_new identifier id'>new</span> <span class='rubyid_my_generator identifier id'>my_generator</span><span class='div op'>/</span><span class='rubyid_example identifier id'>example</span><span class='dot token'>.</span><span class='rubyid_c identifier id'>c</span>
<span class='rubyid_Created constant id'>Created</span> <span class='rubyid_cog identifier id'>cog</span><span class='div op'>/</span><span class='rubyid_templates identifier id'>templates</span><span class='div op'>/</span><span class='rubyid_my_generator identifier id'>my_generator</span>
<span class='rubyid_Created constant id'>Created</span> <span class='rubyid_cog identifier id'>cog</span><span class='div op'>/</span><span class='rubyid_templates identifier id'>templates</span><span class='div op'>/</span><span class='rubyid_my_generator identifier id'>my_generator</span><span class='div op'>/</span><span class='rubyid_example identifier id'>example</span><span class='dot token'>.</span><span class='rubyid_c identifier id'>c</span><span class='dot token'>.</span><span class='rubyid_erb identifier id'>erb</span>
</code></pre>

<p>The new template will be empty. Edit it with the following example</p>

<pre class="code c"><code>&lt;%= warning %&gt; 

void &lt;%= @method_name %&gt;()
{
    // ...
}
</code></pre>

<p>Then modify <code>my_generator.rb</code> like this</p>

<pre class="code ruby"><code><span class='rubyid_@method_name ivar id'>@method_name</span> <span class='assign token'>=</span> <span class='string val'>'example'</span>
<span class='rubyid_stamp identifier id'>stamp</span> <span class='string val'>'my_generator/example.c'</span><span class='comma token'>,</span> <span class='string val'>'generated_example.c'</span>
</code></pre>

<p>The generator would be executed like this</p>

<pre class="code bash"><code>$ cog gen run my_generator
Created src/generated_example.c
</code></pre>

<p>Listing of <code>generated_example.c</code></p>

<pre class="code c"><code>/*
-------------------------------------------------------------------------------

  WARNING

  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
  be lost the next time this file is regenerated.

  This file was generated using cog
  https://github.com/ktonon/cog

-------------------------------------------------------------------------------
 */ 

void example()
{
    // ...
}
</code></pre>

<p>Get a list of the generators like this</p>

<pre class="code bash"><code>$ cog gen list
[my_app] my_generator
[cog]    sort
</code></pre>

<h2>Templates</h2>

<p>In the example from the previous section, you may have noticed that the
generator method <code>&lt;%= warning %&gt;</code> produced a warning message correctly
formatted as a comment. If you look at the implementation of the <a href="http://ktonon.github.com/cog/Cog/Generator/LanguageMethods.html#warning-instance_method">warning</a>
method, you&#39;ll see that its just a shortcut for rendering the <code>warning.erb</code>
template and passing it through a <a href="http://ktonon.github.com/cog/Cog/Generator/Filters.html#comment-instance_method">comment</a> filter.</p>

<p>This <code>warning.erb</code> template comes built-in with cog. You can see a list of all the
available templates like this</p>

<pre class="code bash"><code>$ cog template list
[basic]  basic/generator.rb
[cog]    cog/Cogfile
[cog]    cog/plugin/generator.rb.erb
[cog]    cog/plugin/plugin.rb
[my_app] my_generator/example.c
[cog]    warning
</code></pre>

<p>Note that the <code>.erb</code> extensions are omitted from the listing. If you don&#39;t like
the default warning message and want to use a different one you can override it</p>

<pre class="code bash"><code>$ cog tm new warning
Created cog/templates/warning.erb
</code></pre>

<p>Listing the templates again would now show that there are two <code>warning.erb</code>
templates and that the project version overrides the built-in version</p>

<pre class="code bash"><code>[cog &lt; my_app] warning
</code></pre>

<h2>Embeds</h2>

<p>As shown above, the <a href="http://ktonon.github.com/cog/Cog/Generator.html#method-i-stamp">stamp</a> method can be used to create files which are
entirely generated. While this is useful, it might at times be more convenient
to inject generated content directly into an otherwise manually maintained
file. Such an injection should be automatically updated when the generated
content changes, but leave the rest of the file alone. <code>cog</code> provides this kind
of functionality through embeds. For example, consider the following generator</p>

<pre class="code ruby"><code><span class='float val'>1</span><span class='dot token'>.</span><span class='rubyid_upto identifier id'>upto</span><span class='lparen token'>(</span><span class='integer val'>5</span><span class='rparen token'>)</span><span class='dot token'>.</span><span class='rubyid_each identifier id'>each</span> <span class='rubyid_do do kw'>do</span> <span class='bitor op'>|</span><span class='rubyid_i identifier id'>i</span><span class='bitor op'>|</span>
  <span class='rubyid_stamp identifier id'>stamp</span> <span class='string val'>'widget.cpp'</span><span class='comma token'>,</span> <span class='dstring node'>&quot;widget_#{i}.cpp&quot;</span>
  <span class='rubyid_stamp identifier id'>stamp</span> <span class='string val'>'widget.h'</span><span class='comma token'>,</span> <span class='dstring node'>&quot;widget_#{i}.h&quot;</span>
<span class='rubyid_end end kw'>end</span>
</code></pre>

<p>This generator would add 10 new files to a project. These files would need to
be included in the project&#39;s build script. It would be tedious to enter them
manually. It would make sense for the generator to maintain the list of build
files. Depending on the build tool being used, it might be possible to generate
a partial build file and include it by reference in the main build file.</p>

<p>Another approach would be to use a embed to inject the build instuctions for
the generator into the main build file. For example, consider a Qt project file</p>

<pre class="code text"><code>SOURCES += main.cpp Donkey.cpp
HEADERS += Donkey.h

# cog: widget-files
</code></pre>

<p>The last line is a comment that Qt will ignore, but which <code>cog</code> will recognize
as an embed hook named <tt>&#39;widget-files&#39;</tt>. Once the hook is in place,
it&#39;s up to a generator to provide the content which will be injected beneath
the hook. Consider again the generator from above, with a few modifications</p>

<pre class="code ruby"><code><span class='rubyid_@widgets ivar id'>@widgets</span> <span class='assign token'>=</span> <span class='float val'>1</span><span class='dot token'>.</span><span class='rubyid_upto identifier id'>upto</span><span class='lparen token'>(</span><span class='integer val'>5</span><span class='rparen token'>)</span>
<span class='rubyid_@widgets ivar id'>@widgets</span><span class='dot token'>.</span><span class='rubyid_each identifier id'>each</span> <span class='rubyid_do do kw'>do</span> <span class='bitor op'>|</span><span class='rubyid_i identifier id'>i</span><span class='bitor op'>|</span>
  <span class='rubyid_stamp identifier id'>stamp</span> <span class='string val'>'widget.cpp'</span><span class='comma token'>,</span> <span class='dstring node'>&quot;widget_#{i}.cpp&quot;</span>
  <span class='rubyid_stamp identifier id'>stamp</span> <span class='string val'>'widget.h'</span><span class='comma token'>,</span> <span class='dstring node'>&quot;widget_#{i}.h&quot;</span>
<span class='rubyid_end end kw'>end</span>

<span class='rubyid_embed identifier id'>embed</span> <span class='string val'>'widget-files'</span> <span class='rubyid_do do kw'>do</span>
  <span class='rubyid_stamp identifier id'>stamp</span> <span class='string val'>'widget.pro'</span> <span class='comment val'># uses the @widgets context and returns a string</span>
<span class='rubyid_end end kw'>end</span>
</code></pre>

<p>The <a href="http://ktonon.github.com/cog/Cog/Generator.html#embed-instance_method">embed</a> method takes the name of the hook as an argument. The expansion
value is returned by the provided block. In this case a <a href="http://ktonon.github.com/cog/Cog/Generator.html#method-i-stamp">stamp</a> was used to
pull the content from a template, but a string could also be constructed in the
block without using a template. Running this generator would now inject content
beneath the embed directive in the build file.</p>

<pre class="code text"><code>SOURCES += main.cpp Donkey.cpp
HEADERS += Donkey.h

# cog: widget-files {
SOURCES += widget_1.cpp widget_2.cpp widget_3.cpp widget_4.cpp widget_5.cpp
HEADERS += widget_1.h widget_2.h widget_3.h widget_4.h widget_5.h
# cog: }
</code></pre>

<p>Embeds are only updated when the generated content changes. So running the
generator a second time would not touch the file.</p>

<h2>Plugins</h2>

<p>While it is possible to place all code generation logic into a generator
script, you might also consider writing a <code>cog</code> plugin.</p>

<p>Very loosely, a plugin should provide</p>

<ul>
<li>a <a href="http://jroller.com/rolsen/entry/building_a_dsl_in_ruby">domain specific language</a> in which generator scripts can be written</li>
<li>a template for creating generators in that <code>DSL</code>

<ul>
<li>the purpose of the template is to help users of the plugin get started writing a generator</li>
</ul></li>
</ul>

<p>You can tell <code>cog</code> to help you get started writing a plugin. For example, if
you wanted to write a command line interface generation tool and call it
<code>cons</code>, you would do this</p>

<pre class="code bash"><code>$ cog plugin new cons
Created cog/plugins/cons/Cogfile
Created cog/plugins/cons/lib/cons.rb
Created cog/plugins/cons/templates/cons/generator.rb.erb
</code></pre>

<p>When operating in the context of a project, the plugin will be created under
the <a href="http://ktonon.github.com/cog/Cog/Config/ProjectConfig.html#project_plugin_path-instance_method">project_plugin_path</a>, and will be available to that project only.
Outside the context of a project it would be created under the current working
directory. If that directory is not on the <a href="http://ktonon.github.com/cog/Cog/Config.html#plugin_path-instance_method">plugin_path</a>, then <code>cog</code> will not
know how to find it.</p>

<p>If you want to share a plugin between multiple projects, you have a few options.</p>

<ul>
<li>distribute it as a gem

<ul>
<li>make sure to include the Cogfile in the gem</li>
</ul></li>
<li>create the plugin under your <tt>${HOME}/.cog</tt> directory

<ul>
<li>this directory and a user <code>Cogfile</code> are created the first time you run <code>cog init</code></li>
</ul></li>
</ul>

<p>You can see a list of the available plugins like this</p>

<pre class="code bash"><code>$ cog plugin list
[cog]    basic
[my_app] cons
</code></pre>

<p>As noted before, a plugin should contain a template for making generators. In
the above example, that is the <code>generator.rb.erb</code> template. The instructions
for stamping the generator are in the plugin&#39;s <a href="http://ktonon.github.com/cog/Cog/DSL/Cogfile.html">Cogfile</a>. You can make a
generator for a particular plugin like this</p>

<pre class="code bash"><code>$ cog gen new -p cons my_cons
Created cog/generators/my_cons.rb
</code></pre>
</div></div>

    <div id="footer">
  Generated on Sat Dec 29 23:01:46 2012 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.3 (ruby-1.8.7).
</div>

  </body>
</html>