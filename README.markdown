![cog](http://ktonon.github.com/cog/images/cog-logo-small.png)

`cog` is a command line utility that makes it a bit easier to organize a project
which uses code generation.

The documentation on this page is synchronized with the git repository.
For docs on the [currently released gem](https://rubygems.org/gems/cog) (version 0.2.0)
see [ktonon.github.com/cog](http://ktonon.github.com/cog/frames.html).
See also the following resources,

* [Video introduction to cog](http://youtu.be/lH_q0aPqRzo)

Note that _this project is still under development_.

Table of contents
-----------------

1. [Getting Started](#getting-started) - Install `cog` and prepare a project
1. [Generators](#generators) - Create ruby scripts which generate code
1. [Templates](#templates) - Use ERB templates to help generators
1. [Snippets](#snippets) - Generate code segments into otherwise manually maintained code
1. [Tools](#tools) - Extend `cog` by writing tools

Getting Started
---------------

Install the `cog` gem from a terminal

```bash
$ gem install cog
```

Consider an existing project with the following directory layout

```text
PROJECT_ROOT/
             Makefile
             src/
                 main.cpp
                 ...
```

To use `cog` with this project, you would first open a terminal and change to
the `PROJECT_ROOT` directory. Then enter

```bash
$ cog init
Created Cogfile
Created cog/generators
Created cog/templates
```

Now your project's directory layout will look like this

```text
PROJECT_ROOT/
           + Cogfile
             Makefile
             src/
                 main.cpp
                 ...
           + cog/
           +     generators/
           +     templates/
```

The [Cogfile](http://ktonon.github.com/cog/Cog/Config/Cogfile.html) configures
`cog` for use with your project. In short, it tells `cog` where to find generators and templates
and where to put generated source code.

Generators
----------

A generator is a ruby file which resides in the `project_generators_path`
and performs its work at the time it is required.
A basic generator can be created using the command line tool once a project has
been initialized

```bash
$ cog generator new my_generator
Created cog/generators/my_generator.rb
Created cog/templates/my_generator.cpp.erb
Created cog/templates/my_generator.hpp.erb
```

Notice that a generator with C++ templates was created. That is because the
[default_target_language](http://ktonon.github.com/cog/Cog/Config/Cogfile.html#default_target_language-instance_method)
in the Cogfile was set to `c++`. You can see a list of other possible settings by running `cog language list`.

Here is what `my_generator.rb` will look like

```ruby
require 'cog'
include Cog::Generator

# Setup the template context
@class = 'my_generator'

# Render the templates
stamp 'my_generator.cpp', 'generated_my_generator.cpp'
stamp 'my_generator.hpp', 'generated_my_generator.hpp'
```

The inclusion of the mixin
[Cog::Generator](http://ktonon.github.com/cog/Cog/Generator.html) provides an interface for easily
generating source code from templates. The
[stamp](http://ktonon.github.com/cog/Cog/Generator.html#method-i-stamp) method
is particularly useful. If finds an [ERB template](http://www.stuartellis.eu/articles/erb/)
in the [template_paths](http://ktonon.github.com/cog/Cog/Config.html#template_paths-instance_method)
and renders it to a file under the
[project_source_path](http://ktonon.github.com/cog/Cog/Config.html#project_source_path-instance_method).

This is what `my_generator.hpp.erb` will look like

```c++
<%= warning %> 

class <%= @class %>
{
    <%= @class %>();
};
```

Now that you have a generator, you can run it like this

```bash
$ cog gen run my_generator
Created src/generated_my_generator.cpp
Created src/generated_my_generator.hpp
```

and the contents of the generated file will be

```c++
/*
-------------------------------------------------------------------------------

  WARNING

  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
  be lost the next time this file is regenerated.
   
  This file was generated using cog
  https://github.com/ktonon/cog

-------------------------------------------------------------------------------
 */ 

class my_generator
{
	my_generator();
};
```

You can also list the project's generators like this

```bash
$ cog gen list
my_generator

$ cog gen new --language=c# fishy
Created cog/generators/fishy.rb
Created cog/templates/fishy.cs.erb

$ cog generator list
fishy
my_generator
```

You can run all of the project's generators by excluding the generator name. You don't even need to specify the `run` sub-command in this case, as it is the default. So very concisely,

```bash
$ cog gen
Created src/generated_fishy.cs
```

In this case, both generators are run, but the original `my_generator` hasn't changed, so the generated file `generated_my_generator.txt` will not be touched.

Templates
---------

In the example from the previous section, you may have noticed that the
generator method `<%= warning %>` produced this text in the generated files

```c++
/*
-------------------------------------------------------------------------------

  WARNING

  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
  be lost the next time this file is regenerated.
   
  This file was generated using cog
  https://github.com/ktonon/cog

-------------------------------------------------------------------------------
 */ 
```

If you look at the implementation of the `warning` method, you'll see that its
just a shortcut for rendering the `warning.erb` template and passing it through
a `comment` filter,

```ruby
def warning
  stamp 'warning', :filter => 'comment'
end
```

This warning template is built-in with cog. You can see a list of the available
templates,

```bash
$ cog template list
[built-in] basic/generator.rb
[built-in] basic/template.cpp.erb
[built-in] basic/template.hpp.erb
...
[project]  my_generator.cpp
[project]  my_generator.hpp
[built-in] warning
```

If you don't like that warning message and want to use a different one you can
override it,

```bash
$ cog tm new --force-override warning
Created cog/templates/warning.erb
```

Now when you list the templates, you'll see that the project template for
warning overrides the built-in one,

```bash
$ cog tm
[built-in]           basic/generator.rb
[built-in]           basic/template.cpp.erb
[built-in]           basic/template.hpp.erb
...
[project]            my_generator.cpp
[project]            my_generator.hpp
[built-in < project] warning
```

Snippets
--------

In previous sections, you've seen how the `stamp` method can be used to create
files which are entirely generated. While this is useful, sometimes it might be
more convenient to inject generated content directly into an otherwise manually
maintained file. Such an injection should be able to update the generated
content when it changes, but leave the rest of the file alone. `cog` provides
this kind of functionality through snippets.

Take the following generator as an example,

```ruby
require 'cog'
include Cog::Generator

1.upto(5).each do |i|
  stamp 'widget.cpp', "widget_#{i}.cpp"
  stamp 'widget.h', "widget_#{i}.h"
end
```

This generator will add 10 new files to the project. These files will need to
be included in the project's build script. It would be tedious to have to enter
them manually and it would make more sense for the generator to maintain the
list of build files. Depending on your build tool, you might be able to
generate a partial build file and include it in the main one. Or you could just
use a snippet to inject generated build instructions directly into an otherwise
manually maintained build file.

For example, consider a Qt project file,

```text
SOURCES += main.cpp Donkey.cpp
HEADERS += Donkey.h
```

You can added a snippet hook into the project file as a special comment which
`cog` will recognize,

```text
SOURCES += main.cpp Donkey.cpp
HEADERS += Donkey.h

# cog: snippet(widget-files)
```

Now that you have the hook, <tt>'widget-files'</tt> in there, you need to
provide a value for it. You do this in your generator with the `snippet` method,

```ruby
require 'cog'
include Cog::Generator

@widgets = 1.upto(5)
@widgets.each do |i|
  stamp 'widget.cpp', "widget_#{i}.cpp"
  stamp 'widget.h', "widget_#{i}.h"
end

snippet 'widget-files' do
  stamp 'widget.pro' # uses the @widgets context and returns a string
end
```

Once you've done this, the next time you run your generator the snippet will be expanded,

```text
SOURCES += main.cpp Donkey.cpp
HEADERS += Donkey.h

# cog: snippet(widget-files) {
SOURCES += widget_1.cpp widget_2.cpp widget_3.cpp widget_4.cpp widget_5.cpp
HEADERS += widget_1.h widget_2.h widget_3.h widget_4.h widget_5.h
# }
```

Running the generator a second time will not modify the build file, since the
snippet content won't have changed.


Tools
-----

While its possible to place all the code for your generator in the
`project_generators_path`, you might also consider writing a tool.

A tool is a separately distributed ruby gem which can be registered with `cog`
and contains templates for generator files. A tool should also provide a domain
specific language (DSL) in which the generator files created by the tool are
written.

You can tell `cog` to help you get started writing a tool. For example, if you
wanted to write a command line interface generation tool and call it `cons`, you
would do this

```bash
$ cog tool new cons
Created cons/lib/cons.rb
Created cons/lib/cons/cog_tool.rb
Created cons/lib/cons/version.rb
Created cons/cog/templates/cons/generator.rb.erb
Created cons/cog/templates/cons/cons.txt.erb
Created cons/Gemfile
Created cons/Rakefile
Created cons/cons.gemspec
Created cons/LICENSE
Created cons/README.markdown
```

Tools are available across multiple projects. There are tools which come
built-in with `cog` and there are custom tools. In the previous example `cons`
was a custom tool. The set of custom tools are defined by the value of the
`COG_TOOLS` environment variable. The value of this variable is a colon (`:`)
separated list. Each entry should take one of two formats, either

* The name of the tool. For example `cons`.
* File system path to the `cog_tool.rb` file. For example `/Users/ktonon/cons/lib/cons/cog_tool.rb`.  This form is useful during development of the tool itself.

The directory structure of the tool is important. In the previous example, `cog` will assumes that the following paths will not be renamed or moved with respect to each other

```
cons/lib/cons.rb
cons/lib/cons/cog_tool.rb
cons/cog/templates/
```

The `cog_tool.rb` is particularly important. It defines the method which stamps new generators for the tool. It looks like this

```ruby
require 'cog'

# Register cons as a tool with cog
Cog::Config.instance.register_tool __FILE__ do |tool|

  # Define how new cons generators are created
  #
  # Add context as required by your generator template.
  #
  # When the block is executed, +self+ will be an instance of Cog::Config::Tool::GeneratorStamper
  tool.stamp_generator do
    stamp 'cons/generator.rb', generator_dest, :absolute_destination => true
  end
  
end
```

You can see a list of the available tools like this

```bash
$ cog tool list
basic
cons
```

As noted before, a tool should contain a template for making generators. In the
above example, that is the `generator.rb.erb` template. You can make a generator
using a custom tool like this

```bash
$ cog --tool=cons gen new my_cons
Created cog/generators/my_cons.rb
```

This new generator will look something like this

```ruby
require 'cons'

Cons.widget 'my_cons' do |w|
  w.context = 'this is the context'
end
```

There is no explicit call to generate, but there is still a `generate` method on
the `Widget` class and it is called automatically when the block terminates.
Here is what the root tool file `cons.rb` will look like

```ruby
$LOAD_PATH << File.join(File.dirname(__FILE__))
require 'cons/version'
require 'cog'

# Custom cog tool cons 
module Cons 
  
  # Root of the DSL
  # Feel free to rename this to something more appropriate
  def self.widget(generator_name, &block)
    w = Widget.new generator_name
    block.call w

    # Activate cons while rendering templates
    # so that cog will be able to find cons templates
    Cog::Config.instance.activate_tool 'cons' do
      w.generate
    end

    nil
  end

  # Root type of the DSL
  # You'll want to rename this to something more meaningful
  # and probably place it in a separate file.
  class Widget
    
    include Cog::Generator
    
    attr_accessor :context
    
    def initialize(generator_name)
      @generator_name = generator_name
    end
    
    def generate
      stamp 'cons/cons.txt', "generated_#{@generator_name}.txt"
    end
  end
end
```
