![cog](http://ktonon.github.com/cog/images/cog-logo-small.png)

`cog` is a command line utility that makes it a bit easier to organize a project
which uses code generation.

The documentation on this page is synchronized with the git repository. For docs on the currently released gem (0.1.4) see [ktonon.github.com/cog](http://ktonon.github.com/cog/frames.html). See also the following resources,

* [Video introduction to cog](http://youtu.be/lH_q0aPqRzo)

Note that _this project is still under development_.

Get it
------

Install the [cog gem](https://rubygems.org/gems/cog) from a terminal

```bash
$ gem install cog
```

Prepare a project
-----------------

Consider an existing project with the following directory layout

```text
PROJECT_ROOT/
             Makefile
             src/
                 main.cpp
                 ...
```

To use `cog` with this project, you would first open a terminal and change to
the `PROJECT_ROOT` directory. Then enter

```bash
$ cog init
Created Cogfile
Created cog/generators
Created cog/templates
```

Now your project's directory layout will look like this

```text
PROJECT_ROOT/
           + Cogfile
             Makefile
             src/
                 main.cpp
                 ...
           + cog/
           +     generators/
           +     templates/
```

The [Cogfile](http://ktonon.github.com/cog/Cog/Config/Cogfile.html) configures
`cog` for use with your project. In short, it tells `cog` where to find generators and templates
and where to put generated source code. It should look like this when you first create
it

```ruby
# All paths are relative to the directory containing this file.

# Define the directory in which to find project generators
project_generators_path 'cog/generators'

# Define the directory in which to find custom project templates
project_templates_path 'cog/templates'

# Define the directory to which project source code is generated
project_source_path 'src'

# Explicitly specify a mapping from file extensions to languages
#
# key => value pairs from this mapping will override the default
# language map supplied by +cog+
#
# Type `cog language list` to see a list of supported languages
# and the current file extension mappings
language_extensions({
  # :h => 'c++',
  })

# Define the target language which should be used when
# creating generators, and no language is explicitly specified
default_target_language 'c++'
```

Generators
----------

A generator is a ruby file which resides in the `project_generators_path`
and performs its work at the time it is required.
A basic generator can be created using the command line tool once a project has
been initialized

```bash
$ cog generator new my_generator
Created cog/generators/my_generator.rb
Created cog/templates/my_generator.cpp.erb
Created cog/templates/my_generator.hpp.erb
```

Notice that a generator with C++ templates was created. That is because the
[default_target_language](http://ktonon.github.com/cog/Cog/Config/Cogfile.html#default_target_language-instance_method)
in the Cogfile was set to `c++`. You can see a list of other possible settings by running `cog language list`.

Here is what `my_generator.rb` will look like

```ruby
require 'cog'
include Cog::Generator

# Setup the template context
@class = 'my_generator'

# Render the templates
stamp 'my_generator.cpp', 'generated_my_generator.cpp'
stamp 'my_generator.hpp', 'generated_my_generator.hpp'
```

The inclusion of the mixin
[Cog::Generator](http://ktonon.github.com/cog/Cog/Generator.html) provides an interface for easily
generating source code from templates. The
[stamp](http://ktonon.github.com/cog/Cog/Generator.html#method-i-stamp) method
is particularly useful. If finds an [ERB template](http://www.stuartellis.eu/articles/erb/)
in the [template_paths](http://ktonon.github.com/cog/Cog/Config.html#template_paths-instance_method)
and renders it to a file under the
[project_source_path](http://ktonon.github.com/cog/Cog/Config.html#project_source_path-instance_method).

This is what `my_generator.hpp.erb` will look like

```c++
<%= warning %> 

class <%= @class %>
{
    <%= @class %>();
};
```

Now that you have a generator, you can run it like this

```bash
$ cog gen run my_generator
Created src/generated_my_generator.cpp
Created src/generated_my_generator.hpp
```

and the contents of the generated file will be

```c++
/*
-------------------------------------------------------------------------------

  WARNING

  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
  be lost the next time this file is regenerated.
   
  This file was generated using cog
  https://github.com/ktonon/cog

-------------------------------------------------------------------------------
 */ 

class my_generator
{
	my_generator();
};
```

You can also list the project's generators like this

```bash
$ cog gen list
my_generator

$ cog gen new --language=c# fishy
Created cog/generators/fishy.rb
Created cog/templates/fishy.cs.erb

$ cog generator list
fishy
my_generator
```

You can run all of the project's generators by excluding the generator name. You don't even need to specify the `run` sub-command in this case, as it is the default. So very concisely,

```bash
$ cog gen
Created src/generated_fishy.cs
```

In this case, both generators are run, but the original `my_generator` hasn't changed, so the generated file `generated_my_generator.txt` will not be touched.

Templates
---------

In the example from the previous section, you may have noticed that the generator method `<%= warning %>` produced this text in the generated files

```c++
/*
-------------------------------------------------------------------------------

  WARNING

  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
  be lost the next time this file is regenerated.
   
  This file was generated using cog
  https://github.com/ktonon/cog

-------------------------------------------------------------------------------
 */ 
```

If you look at the implementation of the `warning` method, you'll see that its just a shortcut for rendering the `warning.erb` template and passing it through a `comment` filter,

```ruby
def warning
  stamp 'warning', :filter => 'comment'
end
```

This warning template is built-in with cog. You can see a list of the available templates,

```bash
$ cog template list
[built-in] basic/generator.rb
[built-in] basic/template.cpp.erb
[built-in] basic/template.hpp.erb
...
[project]  my_generator.cpp
[project]  my_generator.hpp
[built-in] warning
```

If you don't like that warning message and want to use a different one you can override it,

```bash
$ cog tm new --force-override warning
Created cog/templates/warning.erb
```

Now when you list the templates, you'll see that the project template for warning overrides the built-in one,

```bash
$ cog tm
[built-in]           basic/generator.rb
[built-in]           basic/template.cpp.erb
[built-in]           basic/template.hpp.erb
...
[project]            my_generator.cpp
[project]            my_generator.hpp
[built-in < project] warning
```

Tools
-----

While its possible to place all the code for your generator in the
`project_generators_path`, you might also consider writing a tool.

A tool is a separately distributed ruby gem which can be registered with `cog`
and contains templates for generator files. A tool should also provide a domain
specific language (DSL) in which the generator files created by the tool are
written.

You can tell `cog` to help you get started writing a tool. For example, if you
wanted to write a command line interface generation tool and call it `cons`, you
would do this

```bash
$ cog tool new cons
Created cons/lib/cons.rb
Created cons/lib/cons/cog_tool.rb
Created cons/lib/cons/version.rb
Created cons/cog/templates/cons/generator.rb.erb
Created cons/cog/templates/cons/cons.txt.erb
Created cons/Gemfile
Created cons/Rakefile
Created cons/cons.gemspec
Created cons/LICENSE
Created cons/README.markdown
```

Tools are available across multiple projects. There are tools which come
built-in with `cog` and there are custom tools. In the previous example `cons`
was a custom tool. The set of custom tools are defined by the value of the
`COG_TOOLS` environment variable. The value of this variable is a colon (`:`)
separated list. Each entry should take one of two formats, either

* The name of the tool. For example `cons`.
* File system path to the `cog_tool.rb` file. For example `/Users/ktonon/cons/lib/cons/cog_tool.rb`.  This form is useful during development of the tool itself.

The directory structure of the tool is important. In the previous example, `cog` will assumes that the following paths will not be renamed or moved with respect to each other

```
cons/lib/cons.rb
cons/lib/cons/cog_tool.rb
cons/cog/templates/
```

The `cog_tool.rb` is particularly important. It defines the method which stamps new generators for the tool. It looks like this

```ruby
require 'cog'

# Register cons as a tool with cog
Cog::Config.instance.register_tool __FILE__ do |tool|

  # Define how new cons generators are created
  #
  # Add context as required by your generator template.
  #
  # When the block is executed, +self+ will be an instance of Cog::Config::Tool::GeneratorStamper
  tool.stamp_generator do
    stamp 'cons/generator.rb', generator_dest, :absolute_destination => true
  end
  
end
```

You can see a list of the available tools like this

```bash
$ cog tool list
basic
cons
```

As noted before, a tool should contain a template for making generators. In the
above example, that is the `generator.rb.erb` template. You can make a generator
using a custom tool like this

```bash
$ cog --tool=cons gen new my_cons
Created cog/generators/my_cons.rb
```

This new generator will look something like this

```ruby
require 'cons'

Cons.widget 'my_cons' do |w|
  w.context = 'this is the context'
end
```

There is no explicit call to generate, but there is still a `generate` method on
the `Widget` class and it is called automatically when the block terminates.
Here is what the root tool file `cons.rb` will look like

```ruby
$LOAD_PATH << File.join(File.dirname(__FILE__))
require 'cons/version'
require 'cog'

# Custom cog tool cons 
module Cons 
  
  # Root of the DSL
  # Feel free to rename this to something more appropriate
  def self.widget(generator_name, &block)
    w = Widget.new generator_name
    block.call w

    # Activate cons while rendering templates
    # so that cog will be able to find cons templates
    Cog::Config.instance.activate_tool 'cons' do
      w.generate
    end

    nil
  end

  # Root type of the DSL
  # You'll want to rename this to something more meaningful
  # and probably place it in a separate file.
  class Widget
    
    include Cog::Generator
    
    attr_accessor :context
    
    def initialize(generator_name)
      @generator_name = generator_name
    end
    
    def generate
      stamp 'cons/cons.txt', "generated_#{@generator_name}.txt"
    end
  end
end
```

API Documentation
-----------------

To get the most out of `cog` you'll need to refer to the [API docs](http://ktonon.github.com/cog/).
