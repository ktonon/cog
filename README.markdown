![cog](http://ktonon.github.com/cog/images/cog-logo-small.png)

[![Code Climate](https://codeclimate.com/badge.png)](https://codeclimate.com/github/ktonon/cog)

`cog` is a command line utility that makes it easy to organize a project which
uses code generation.

The documentation on this page is synchronized with the git repository.
For docs on the currently released [gem](https://rubygems.org/gems/cog) (version 0.2.2)
see [ktonon.github.com/cog](http://ktonon.github.com/cog/frames.html).
See also the following resources,

* [Video introduction to cog](http://youtu.be/lH_q0aPqRzo)

Note that _this project is still under development_.

Table of contents
-----------------

1. [Getting Started](#getting-started) - Install `cog` and prepare a project
1. [Generators](#generators) - Create ruby scripts which generate code
1. [Templates](#templates) - Use ERB templates to help generators
1. [Embeds](#embeds) - Generate code segments into otherwise manually maintained code
1. [Tools](#tools) - Extend `cog` by writing tools

Getting Started
---------------

Install the `cog` gem

```bash
$ gem install cog
```

Once installed prepare a project for use with `cog`. Open a terminal in the root directory
of your project

```bash
$ cog init
Created Cogfile
```

This will add a [Cogfile](http://ktonon.github.com/cog/Cog/Config/Cogfile.html)
which configures `cog` for use with the project. In short, it tells `cog` where
to find generators and templates and where to put generated source code. Open
the `Cogfile` to find out more, each setting is documented. Most settings can
be left as-is, but the
[project_source_path](http://ktonon.github.com/cog/Cog/Config/ProjectMethods.html#project_source_path-instance_method) might need to be changed if the source files are not in
a directory called `src` relative the directory containing the `Cogfile`.

Generators
----------

A generator is a ruby file which resides in the
[project_generators_path](http://ktonon.github.com/cog/Cog/Config/ProjectMethods.html#project_generators_path-instance_method)
and performs its work at the time it is required. A basic generator can be
created using the command line tool once a project has been initialized

```bash
$ cog generator new my_generator
Created cog/generators/my_generator.rb
```

`my_generator.rb` will contain a bare minimum of code

```ruby
require 'cog'
include Cog::Generator

# This is the my_generator generator
```

The inclusion of the mixin
[Cog::Generator](http://ktonon.github.com/cog/Cog/Generator.html) provides an interface for easily
generating source code from templates. The [stamp](http://ktonon.github.com/cog/Cog/Generator.html#method-i-stamp) method
is particularly useful. If finds an [ERB template](http://www.stuartellis.eu/articles/erb/)
in the [template_paths](http://ktonon.github.com/cog/Cog/Config.html#template_paths-instance_method)
and renders it to a file under the
[project_source_path](http://ktonon.github.com/cog/Cog/Config/ProjectMethods.html#project_source_path-instance_method).
To use the `stamp` method first create a template

```ruby
$ cog generator template new my_generator/example.c
Created cog/templates/my_generator
Created cog/templates/my_generator/example.c.erb
```

The new template will be empty. Edit it with the following example

```c
<%= warning %> 

void <%= @method_name %>()
{
    // ...
}
```

Then modify `my_generator.rb` like this

```ruby
require 'cog'
include Cog::Generator

# This is the my_generator generator

@method_name = 'example'
stamp 'my_generator/example.c', 'generated_example.c'
```

The generator would be executed like this

```bash
$ cog gen run my_generator
Created src/generated_example.c
```

Listing of `generated_example.c`

```c
/*
-------------------------------------------------------------------------------

  WARNING

  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
  be lost the next time this file is regenerated.
   
  This file was generated using cog
  https://github.com/ktonon/cog

-------------------------------------------------------------------------------
 */ 

void example()
{
    // ...
}
```

Get a list of the project's generators like this

```bash
$ cog gen list
my_generator
```

Templates
---------

In the example from the previous section, you may have noticed that the
generator method `<%= warning %>` produced this text in the generated files

```c++
/*
-------------------------------------------------------------------------------

  WARNING

  This is a generated file. DO NOT EDIT THIS FILE! Your changes will
  be lost the next time this file is regenerated.
   
  This file was generated using cog
  https://github.com/ktonon/cog

-------------------------------------------------------------------------------
 */ 
```

If you look at the implementation of the [warning](http://ktonon.github.com/cog/Cog/Generator/LanguageMethods.html#warning-instance_method)
method, you'll see that its just a shortcut for rendering the `warning.erb`
template and passing it through a [comment](http://ktonon.github.com/cog/Cog/Generator/Filters.html#comment-instance_method)
filter

```ruby
def warning
  stamp 'warning', :filter => 'comment'
end
```

This warning template comes built-in with cog. You can see a list of the available
templates, both built-in and project specific

```bash
$ cog template list
[project]  my_generator/example.c
[built-in] warning
```

If you don't like the default warning message and want to use a different one you can
override it

```bash
$ cog tm new --force-override warning
Created cog/templates/warning.erb
```

Listing the templates again would now show that there are two `warning.erb`
templates and that the project version overrides the built-in version

```bash
$ cog tm
[project]            my_generator/example.c
[built-in < project] warning
```

Embeds
------

As shown above, the
[stamp](http://ktonon.github.com/cog/Cog/Generator.html#stamp-instance_method)
method can be used to create files which are entirely generated. While this is
useful, it might at times be more convenient to inject generated content
directly into an otherwise manually maintained file. Such an injection should
be automatically updated when the generated content changes, but leave the rest
of the file alone. `cog` provides this kind of functionality through embeds.
For example, consider the following generator

```ruby
require 'cog'
include Cog::Generator

1.upto(5).each do |i|
  stamp 'widget.cpp', "widget_#{i}.cpp"
  stamp 'widget.h', "widget_#{i}.h"
end
```

This generator would add 10 new files to a project. These files would need to
be included in the project's build script. It would be tedious to enter them
manually. It would make sense for the generator to maintain the list of build
files. Depending on the build tool being used, it might be possible to generate
a partial build file and include it by reference in the main build file.

Another approach would be to use a embed to inject the build instuctions for
the generator into the main build file. For example, consider a Qt project file

```text
SOURCES += main.cpp Donkey.cpp
HEADERS += Donkey.h

# cog: widget-files
```

The last line is a comment that Qt will ignore, but which `cog` will recognize
as an embed hook named <tt>'widget-files'</tt>. Once the hook is in place,
it's up to a generator to provide the content which will be injected beneath
the hook. Consider again the generator from above, with a few modifications

```ruby
require 'cog'
include Cog::Generator

@widgets = 1.upto(5)
@widgets.each do |i|
  stamp 'widget.cpp', "widget_#{i}.cpp"
  stamp 'widget.h', "widget_#{i}.h"
end

embed 'widget-files' do
  stamp 'widget.pro' # uses the @widgets context and returns a string
end
```

The [embed](http://ktonon.github.com/cog/Cog/Generator.html#embed-instance_method)
method takes the name of the hook as an argument. The expansion value is
returned by the provided block. In this case a `stamp` was used to pull the
content from a template, but a string could also be constructed in the block
without using a template. Running this generator would now inject content
beneath the embed directive in the build file.

```text
SOURCES += main.cpp Donkey.cpp
HEADERS += Donkey.h

# cog: widget-files {
SOURCES += widget_1.cpp widget_2.cpp widget_3.cpp widget_4.cpp widget_5.cpp
HEADERS += widget_1.h widget_2.h widget_3.h widget_4.h widget_5.h
# cog: }
```

Embeds are only updated when the generated content changes. So running the
generator a second time would not touch the build file.

Tools
-----

While its possible to place all the code for your generator in the
`project_generators_path`, you might also consider writing a tool.

A tool is a separately distributed ruby gem which can be registered with `cog`
and contains templates for generator files. A tool should also provide a domain
specific language (DSL) in which the generator files created by the tool are
written.

You can tell `cog` to help you get started writing a tool. For example, if you
wanted to write a command line interface generation tool and call it `cons`, you
would do this

```bash
$ cog tool new cons
Created cons/lib/cons.rb
Created cons/lib/cons/cog_tool.rb
Created cons/lib/cons/version.rb
Created cons/cog/templates/cons/generator.rb.erb
Created cons/cog/templates/cons/cons.txt.erb
Created cons/Gemfile
Created cons/Rakefile
Created cons/cons.gemspec
Created cons/LICENSE
Created cons/README.markdown
```

Tools are available across multiple projects. There are tools which come
built-in with `cog` and there are custom tools. In the previous example `cons`
was a custom tool. The set of custom tools are defined by the value of the
`COG_TOOLS` environment variable. The value of this variable is a colon (`:`)
separated list. Each entry should take one of two formats, either

* The name of the tool. For example `cons`.
* File system path to the `cog_tool.rb` file. For example `/Users/ktonon/cons/lib/cons/cog_tool.rb`.  This form is useful during development of the tool itself.

The directory structure of the tool is important. In the previous example, `cog` will assumes that the following paths will not be renamed or moved with respect to each other

```
cons/lib/cons.rb
cons/lib/cons/cog_tool.rb
cons/cog/templates/
```

The `cog_tool.rb` is particularly important. It defines the method which stamps new generators for the tool. It looks like this

```ruby
require 'cog'
include Cog::Generator

# Register cons as a tool with cog
Cog.register_tool __FILE__ do |tool|

  # Define a method which creates a cons generator
  tool.stamp_generator do |name, dest|
    
    # Setup context for the template
    @name = name # Generator name
    
    # Create the generator file
    stamp 'cons/generator.rb', dest, :absolute_destination => true
  end
  
end
```

You can see a list of the available tools like this

```bash
$ cog tool list
basic
cons
```

As noted before, a tool should contain a template for making generators. In the
above example, that is the `generator.rb.erb` template. You can make a generator
using a custom tool like this

```bash
$ cog --tool=cons gen new my_cons
Created cog/generators/my_cons.rb
```

This new generator will look something like this

```ruby
require 'cons'

Cons.widget 'my_cons' do |w|
  w.context = 'this is the context'
end
```

There is no explicit call to generate, but there is still a `generate` method on
the `Widget` class and it is called automatically when the block terminates.
Here is what the root tool file `cons.rb` will look like

```ruby
$LOAD_PATH << File.join(File.dirname(__FILE__))
require 'cons/version'
require 'cog'

# Custom cog tool cons 
module Cons 
  
  # Root of the DSL
  # Feel free to rename this to something more appropriate
  def self.widget(generator_name, &block)
    w = Widget.new generator_name
    block.call w

    # Activate cons while rendering templates
    # so that cog will be able to find cons templates
    Cog.activate_tool 'cons' do
      w.generate
    end

    nil
  end

  # Root type of the DSL
  # You'll want to rename this to something more meaningful
  # and probably place it in a separate file.
  class Widget
    
    include Cog::Generator
    
    attr_accessor :context
    
    def initialize(generator_name)
      @generator_name = generator_name
    end
    
    def generate
      stamp 'cons/cons.txt', "generated_#{@generator_name}.txt"
    end
  end
end
```
